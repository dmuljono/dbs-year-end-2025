/**
 * Import attendees from CSV
 * Usage: tsx scripts/import_attendees.ts /absolute/path/to/attendees.csv
 * Prints only a summary to stdout. No PII is emitted.
 */
import fs from "node:fs";
import { parse } from "csv-parse/sync";
import { PrismaClient, Prisma } from "@prisma/client";

const prisma = new PrismaClient();

// Try to load Role enum at runtime (generated by Prisma). If unavailable, fallback.
let RoleEnum: Record<string, string> | null = null;
try {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const client = require("@prisma/client");
  RoleEnum = client.Role || null;
} catch {}

type RawRow = Record<string, string>;
type Row = { employee_id: string; email: string; name: string; role?: string };

function norm(s: string) {
  return s
    .replace(/^\uFEFF/, "")
    .toLowerCase()
    .normalize("NFKC")
    .replace(/[^a-z0-9]+/g, "");
}

function findKey(keys: string[], candidates: string[]): string | undefined {
  const normalized = new Map(keys.map((k) => [norm(k), k] as [string, string]));
  for (const c of candidates) {
    const hit = normalized.get(norm(c));
    if (hit) return hit;
  }
  return undefined;
}

function mapRow(
  r: RawRow,
  keyMap: { employee_id?: string; email?: string; name?: string; role?: string }
): Row | null {
  const eid = keyMap.employee_id ? r[keyMap.employee_id] : undefined;
  const email = keyMap.email ? r[keyMap.email] : undefined;
  const name = keyMap.name ? r[keyMap.name] : undefined;
  const role = keyMap.role ? r[keyMap.role] : undefined;
  if (!eid || !email || !name) return null;
  return {
    employee_id: String(eid).trim(),
    email: String(email).trim(),
    name: String(name).trim(),
    role: role ? String(role).trim() : undefined,
  };
}

function chooseRole(input?: string): string | undefined {
  // If enum exists, map case-insensitively to keys or values; else fallback "attendee"
  if (!input) {
    if (RoleEnum) return RoleEnum["ATTENDEE"] || Object.values(RoleEnum)[0];
    return "attendee";
  }
  const v = input.trim();
  if (RoleEnum) {
    // Try exact key match (case-insensitive)
    for (const key of Object.keys(RoleEnum)) {
      if (key.toLowerCase() === v.toLowerCase()) return RoleEnum[key];
    }
    // Try value match (case-insensitive)
    for (const val of Object.values(RoleEnum)) {
      if (String(val).toLowerCase() === v.toLowerCase()) return val;
    }
    // Default to ATTENDEE (or first enum value)
    return RoleEnum["ATTENDEE"] || Object.values(RoleEnum)[0];
  }
  // No enum available, return lower-case string (schema may default/accept string)
  return v.toLowerCase();
}

function isIntString(s: string) {
  return /^[0-9]+$/.test(s);
}

async function upsertAttendee(
  row: Row,
  defaults: { quota_indomie: number; quota_beer: number; checked_in: boolean }
) {
  const roleVal = chooseRole(row.role);
  // Attempt with string employee_id first
  try {
    await prisma.attendee.upsert({
      where: { employee_id: row.employee_id as any },
      update: {
        email: row.email,
        name: row.name,
        ...(roleVal ? { role: roleVal as any } : {}),
      },
      create: {
        employee_id: row.employee_id as any,
        email: row.email,
        name: row.name,
        ...(roleVal ? { role: roleVal as any } : {}),
        quota_indomie: defaults.quota_indomie,
        quota_beer: defaults.quota_beer,
        checked_in: defaults.checked_in,
      } as any,
    });
    return true;
  } catch (e: any) {
    // If type error due to employee_id expecting Int, retry with integer
    const msg = (e && e.message) || "";
    if (isIntString(row.employee_id)) {
      try {
        const eidNum = Number(row.employee_id);
        await prisma.attendee.upsert({
          where: { employee_id: eidNum as any },
          update: {
            email: row.email,
            name: row.name,
            ...(roleVal ? { role: roleVal as any } : {}),
          },
          create: {
            employee_id: eidNum as any,
            email: row.email,
            name: row.name,
            ...(roleVal ? { role: roleVal as any } : {}),
            quota_indomie: defaults.quota_indomie,
            quota_beer: defaults.quota_beer,
            checked_in: defaults.checked_in,
          } as any,
        });
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
}

async function main() {
  const file = process.argv[2];
  if (!file) {
    console.error("Usage: tsx scripts/import_attendees.ts attendees.csv");
    process.exit(1);
  }
  const content = fs.readFileSync(file, "utf-8");
  const parsed = parse(content, {
    columns: true,
    skip_empty_lines: true,
    trim: true,
  }) as RawRow[];

  const headers = parsed.length ? Object.keys(parsed[0]) : [];

  const keyMap = {
    employee_id: findKey(headers, [
      "employee_id",
      "employee id",
      "emp id",
      "empid",
      "staff id",
      "staffid",
      "eid",
      "employee no",
      "employee number",
      "employee#",
      "staff no",
      "staff number",
      "id",
    ]),
    email: findKey(headers, [
      "email",
      "email address",
      "e-mail",
      "e-mail address",
      "mail",
    ]),
    name: findKey(headers, ["name", "full name", "fullname", "employee name", "staff name"]),
    role: findKey(headers, ["role", "user role", "userrole", "type", "category"]),
  };

  let processed = 0;
  let upserts = 0;
  let skipped = 0;

  // Safe defaults in case schema requires them
  const defaults = { quota_indomie: 1, quota_beer: 3, checked_in: false };

  for (const raw of parsed) {
    processed++;
    const row = mapRow(raw, keyMap);
    if (!row) {
      skipped++;
      continue;
    }
    const ok = await upsertAttendee(row, defaults);
    if (ok) upserts++;
    else skipped++;
  }

  console.log(`Processed ${processed}, Imported/updated ${upserts}, Skipped ${skipped}`);
}

main()
  .then(() => prisma.$disconnect())
  .catch(async (_e) => {
    try { await prisma.$disconnect(); } catch {}
    process.exit(1);
  });